# Puppet Interview Cheat Sheet

## Core Concepts

**Manifest**: Puppet code file (.pp) containing resource declarations
**Resource**: Basic unit of configuration (file, package, service)
**Class**: Named block of Puppet code for grouping resources
**Module**: Collection of manifests, files, and templates
**Node**: Machine managed by Puppet
**Catalog**: Compiled list of resources for a specific node
**Puppet Master/Server**: Central server managing configurations
**Puppet Agent**: Client running on managed nodes
**Facter**: System inventory tool that gathers facts

## Puppet Architecture

```
Puppet Agent (Node) --> Puppet Server --> Catalog Compilation
                                      --> Module/Manifest Storage
Facts --> Puppet Server --> Catalog --> Apply on Agent
```

## Basic Syntax

### Resources
```puppet
# Basic resource syntax
resource_type { 'title':
  attribute => value,
}

# File resource
file { '/etc/motd':
  ensure  => file,
  content => "Welcome to ${hostname}\n",
  owner   => 'root',
  group   => 'root',
  mode    => '0644',
}

# Package resource
package { 'nginx':
  ensure => installed,
}

# Service resource
service { 'nginx':
  ensure => running,
  enable => true,
}

# User resource
user { 'deploy':
  ensure     => present,
  uid        => '1001',
  gid        => '1001',
  shell      => '/bin/bash',
  home       => '/home/deploy',
  managehome => true,
}

# Group resource
group { 'developers':
  ensure => present,
  gid    => '1002',
}

# Exec resource
exec { 'update-system':
  command => '/usr/bin/apt-get update',
  path    => '/usr/bin:/bin',
  unless  => '/usr/bin/test -f /var/cache/apt/updated',
}
```

### Resource Relationships
```puppet
# Before/After
package { 'nginx':
  ensure => installed,
  before => Service['nginx'],
}

service { 'nginx':
  ensure => running,
  after  => Package['nginx'],
}

# Require/Subscribe
service { 'nginx':
  ensure  => running,
  require => Package['nginx'],
}

# Notify/Subscribe (for configuration changes)
file { '/etc/nginx/nginx.conf':
  ensure  => file,
  content => template('nginx/nginx.conf.erb'),
  notify  => Service['nginx'],  # Restart service on change
}

service { 'nginx':
  ensure    => running,
  subscribe => File['/etc/nginx/nginx.conf'],
}

# Chain operator
Package['nginx'] -> File['/etc/nginx/nginx.conf'] ~> Service['nginx']
# -> ensures order
# ~> notifies (triggers refresh)
```

## Classes

### Defining Classes
```puppet
# Simple class
class nginx {
  package { 'nginx':
    ensure => installed,
  }
  
  service { 'nginx':
    ensure  => running,
    enable  => true,
    require => Package['nginx'],
  }
}

# Parameterized class
class nginx (
  String $version = 'installed',
  String $config_file = '/etc/nginx/nginx.conf',
  Boolean $enable_service = true,
) {
  package { 'nginx':
    ensure => $version,
  }
  
  file { $config_file:
    ensure => file,
    source => "puppet:///modules/nginx/${config_file}",
    notify => Service['nginx'],
  }
  
  service { 'nginx':
    ensure  => running,
    enable  => $enable_service,
    require => Package['nginx'],
  }
}
```

### Using Classes
```puppet
# Include class
include nginx

# Declare class with parameters
class { 'nginx':
  version        => '1.19',
  enable_service => true,
}

# Using require
class webserver {
  require nginx
  
  # Other resources
}
```

## Modules

### Module Structure
```
modulename/
├── manifests/
│   ├── init.pp          # Main class
│   ├── install.pp       # Installation class
│   ├── config.pp        # Configuration class
│   └── service.pp       # Service management
├── files/               # Static files
│   └── nginx.conf
├── templates/           # ERB templates
│   └── nginx.conf.erb
├── lib/                 # Custom functions, facts
├── spec/                # Tests
├── examples/            # Example usage
└── metadata.json        # Module metadata
```

### Module Example (nginx/manifests/init.pp)
```puppet
class nginx (
  String $version = 'installed',
  String $package_name = 'nginx',
) {
  contain nginx::install
  contain nginx::config
  contain nginx::service

  Class['nginx::install']
  -> Class['nginx::config']
  ~> Class['nginx::service']
}
```

### nginx/manifests/install.pp
```puppet
class nginx::install {
  package { $nginx::package_name:
    ensure => $nginx::version,
  }
}
```

### nginx/manifests/config.pp
```puppet
class nginx::config {
  file { '/etc/nginx/nginx.conf':
    ensure  => file,
    content => template('nginx/nginx.conf.erb'),
    owner   => 'root',
    group   => 'root',
    mode    => '0644',
  }
}
```

### nginx/manifests/service.pp
```puppet
class nginx::service {
  service { 'nginx':
    ensure     => running,
    enable     => true,
    hasstatus  => true,
    hasrestart => true,
  }
}
```

## Variables and Data Types

### Variables
```puppet
# String
$message = 'Hello World'
$path = "/var/log/${application}/app.log"

# Integer/Float
$port = 8080
$timeout = 30.5

# Boolean
$enable_ssl = true
$debug_mode = false

# Array
$packages = ['nginx', 'vim', 'git']
$ports = [80, 443, 8080]

# Hash
$config = {
  'server_name' => 'example.com',
  'port'        => 80,
  'ssl'         => true,
}

# Accessing array/hash
$first_package = $packages[0]
$server_name = $config['server_name']

# Undef
$optional_value = undef
```

### Facts
```puppet
# System facts (collected by Facter)
$os_family = $facts['os']['family']
$hostname = $facts['networking']['hostname']
$ip_address = $facts['networking']['ip']
$memory = $facts['memory']['system']['total']

# Legacy facts (top-scope variables)
$osfamily
$hostname
$ipaddress

# Using facts in conditionals
if $facts['os']['family'] == 'RedHat' {
  $package_manager = 'yum'
} elsif $facts['os']['family'] == 'Debian' {
  $package_manager = 'apt'
}
```

## Conditionals

### If/Elsif/Else
```puppet
if $facts['os']['family'] == 'RedHat' {
  $apache_package = 'httpd'
  $apache_service = 'httpd'
} elsif $facts['os']['family'] == 'Debian' {
  $apache_package = 'apache2'
  $apache_service = 'apache2'
} else {
  fail('Unsupported operating system')
}
```

### Case Statement
```puppet
case $facts['os']['family'] {
  'RedHat': {
    $package = 'httpd'
  }
  'Debian': {
    $package = 'apache2'
  }
  default: {
    fail('Unsupported OS')
  }
}
```

### Unless
```puppet
unless $facts['os']['family'] == 'Windows' {
  package { 'vim':
    ensure => installed,
  }
}
```

### Selector
```puppet
$package_name = $facts['os']['family'] ? {
  'RedHat' => 'httpd',
  'Debian' => 'apache2',
  default  => 'apache',
}
```

## Templates

### ERB Templates
```erb
# nginx.conf.erb
user <%= @user %>;
worker_processes <%= @worker_processes %>;

events {
    worker_connections <%= @worker_connections %>;
}

http {
    server {
        listen <%= @port %>;
        server_name <%= @server_name %>;
        
        <% @locations.each do |location| -%>
        location <%= location['path'] %> {
            proxy_pass <%= location['proxy_pass'] %>;
        }
        <% end -%>
    }
}
```

### Using Template
```puppet
file { '/etc/nginx/nginx.conf':
  ensure  => file,
  content => template('nginx/nginx.conf.erb'),
}

# Or using epp (Embedded Puppet)
file { '/etc/nginx/nginx.conf':
  ensure  => file,
  content => epp('nginx/nginx.conf.epp', {
    'user'    => 'www-data',
    'port'    => 80,
  }),
}
```

## Functions

### Common Built-in Functions
```puppet
# Notice/Warning/Fail
notice("This is an informational message")
warning("This is a warning")
fail("This will stop compilation")

# File function
file { '/etc/myapp/config':
  ensure => file,
  source => 'puppet:///modules/myapp/config',
}

# Template function
content => template('myapp/config.erb')

# Include function
include nginx
include ['nginx', 'mysql', 'php']

# Defined function
if defined(Class['nginx']) {
  notice('Nginx class is defined')
}

# Hiera lookup
$database_host = lookup('database::host')
$config = lookup('app::config', Hash, 'deep')
```

### Custom Functions (Ruby)
```ruby
# modules/mymodule/lib/puppet/functions/mymodule/reverse.rb
Puppet::Functions.create_function(:'mymodule::reverse') do
  dispatch :reverse do
    param 'String', :input
    return_type 'String'
  end

  def reverse(input)
    input.reverse
  end
end
```

## Hiera

### hiera.yaml (Puppet 5+)
```yaml
version: 5
defaults:
  datadir: data
  data_hash: yaml_data

hierarchy:
  - name: "Per-node data"
    path: "nodes/%{trusted.certname}.yaml"
  
  - name: "Per-OS data"
    path: "os/%{facts.os.family}.yaml"
  
  - name: "Per-environment data"
    path: "environments/%{environment}.yaml"
  
  - name: "Common data"
    path: "common.yaml"
```

### Data Files (YAML)
```yaml
# data/common.yaml
---
nginx::version: '1.19'
nginx::worker_processes: 4
nginx::enable_ssl: true

# data/nodes/web01.example.com.yaml
---
nginx::port: 8080
nginx::server_name: 'web01.example.com'
```

### Using Hiera in Manifests
```puppet
# Automatic parameter lookup
class { 'nginx': }  # Parameters from Hiera

# Explicit lookup
$database_password = lookup('database::password')
$app_config = lookup('app::config', Hash)

# Lookup with default
$port = lookup('app::port', Integer, 'first', 8080)
```

## Defined Types

### Creating Defined Type
```puppet
# modules/nginx/manifests/vhost.pp
define nginx::vhost (
  String $server_name = $title,
  Integer $port = 80,
  String $docroot = "/var/www/${title}",
  Boolean $ssl = false,
) {
  file { "/etc/nginx/sites-available/${title}":
    ensure  => file,
    content => template('nginx/vhost.erb'),
    notify  => Service['nginx'],
  }
  
  file { "/etc/nginx/sites-enabled/${title}":
    ensure => link,
    target => "/etc/nginx/sites-available/${title}",
  }
  
  file { $docroot:
    ensure => directory,
    owner  => 'www-data',
    group  => 'www-data',
  }
}
```

### Using Defined Type
```puppet
nginx::vhost { 'example.com':
  port       => 80,
  docroot    => '/var/www/example',
  ssl        => false,
}

nginx::vhost { 'secure.example.com':
  port       => 443,
  ssl        => true,
}
```

## Puppet Commands

### Agent Commands
```bash
# Run agent
puppet agent -t                        # Test run (one-time)
puppet agent --test
puppet agent --noop                    # Dry run (no changes)

# Manual run with specific environment
puppet agent -t --environment production

# Show configuration
puppet config print

# Show facts
facter
facter os
facter --json

# Parse/validate manifest
puppet parser validate manifest.pp

# Apply manifest locally
puppet apply manifest.pp
puppet apply --noop manifest.pp
```

### Server Commands
```bash
# Start Puppet Server
puppet master --no-daemonize

# Generate certificate
puppet cert list
puppet cert sign node.example.com
puppet cert sign --all

# Modern (Puppet 6+)
puppetserver ca list
puppetserver ca sign --certname node.example.com
```

### Module Commands
```bash
# List installed modules
puppet module list

# Install module
puppet module install puppetlabs-apache
puppet module install puppetlabs-apache --version 5.5.0

# Search modules
puppet module search apache

# Generate module structure
puppet module generate myuser-mymodule

# Upgrade module
puppet module upgrade puppetlabs-apache

# Uninstall module
puppet module uninstall puppetlabs-apache
```

## Testing

### rspec-puppet
```ruby
# spec/classes/nginx_spec.rb
require 'spec_helper'

describe 'nginx' do
  context 'with default parameters' do
    it { is_expected.to compile.with_all_deps }
    it { is_expected.to contain_package('nginx') }
    it { is_expected.to contain_service('nginx').with_ensure('running') }
  end
  
  context 'with custom version' do
    let(:params) {{ :version => '1.19' }}
    it { is_expected.to contain_package('nginx').with_ensure('1.19') }
  end
end
```

## Common Interview Questions

**Q: What is Puppet?**
- Configuration management tool
- Declarative language (describe desired state)
- Client-server architecture
- Idempotent (safe to run multiple times)

**Q: Explain Puppet architecture**
- Agent-Server model
- Agent gathers facts, sends to server
- Server compiles catalog based on manifests
- Agent applies catalog
- Report sent back to server

**Q: What is a Catalog?**
- Compiled configuration for specific node
- Contains all resources and their relationships
- Generated by Puppet Server from manifests
- Applied by Puppet Agent

**Q: Difference between include and require**
- `include`: Declares class, can be used multiple times
- `require`: Declares class and creates dependency
- Both evaluate class, but require adds ordering

**Q: What are Puppet facts?**
- System information collected by Facter
- OS, IP address, hostname, memory, etc.
- Used for conditional logic in manifests
- Custom facts can be created

**Q: Explain idempotency**
- Running Puppet multiple times produces same result
- Only makes changes when needed
- Safe to run repeatedly
- Core principle of Puppet

**Q: What is Hiera?**
- Key-value lookup tool for configuration data
- Separates data from code
- Hierarchical data structure
- Environment and node-specific data

**Q: Difference between manifest, module, and class?**
- Manifest: .pp file with Puppet code
- Class: Named block of code
- Module: Directory structure containing manifests, files, templates

**Q: What is a defined type?**
- Like a class but can be used multiple times
- Creates reusable resource definitions
- Can have multiple instances with different titles

**Q: How to debug Puppet?**
```bash
puppet agent -t --debug
puppet agent -t --noop --verbose
```

**Q: Resource ordering methods?**
- `before`/`after`: Explicit ordering
- `require`/`subscribe`: Dependency relationships
- `notify`/`subscribe`: Trigger refreshes
- Chain operators: `->` and `~>`

**Q: What is r10k?**
- Code management tool for Puppet
- Manages environments and modules
- Integrates with Git
- Deploys code from version control
