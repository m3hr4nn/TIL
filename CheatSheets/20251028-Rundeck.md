# Rundeck Interview Cheat Sheet

## Core Concepts

**Rundeck**: Job scheduler and runbook automation platform
**Project**: Isolated workspace containing jobs and nodes
**Job**: Automated workflow with steps and options
**Node**: Remote or local server/machine to execute commands
**Step**: Individual action in a job (command, script, plugin)
**Execution**: Single run of a job
**ACL**: Access Control List for permissions
**Key Storage**: Secure credential management

## Architecture

```
Rundeck Server
├── Web UI / API
├── Job Scheduler
├── Execution Engine
├── Node Inventory (Resources)
├── Key Storage (Credentials)
└── Plugins (Node Executors, Workflows, Notifications)
```

## Project Structure

### Project Configuration
```yaml
# project.properties
project.name=MyProject
project.description=Production deployment project
project.ssh-keypath=/var/lib/rundeck/.ssh/id_rsa
project.ssh-authentication=privateKey
service.NodeExecutor.default.provider=jsch-ssh
service.FileCopier.default.provider=jsch-scp
```

### Resource Model (Nodes)
```yaml
# resources.yaml
node1.example.com:
  hostname: node1.example.com
  nodename: node1
  description: Web Server 1
  tags: web,production
  osFamily: unix
  osName: Linux
  osVersion: Ubuntu 20.04
  username: deploy
  ssh-key-storage-path: keys/project/deploy-key

node2.example.com:
  hostname: node2.example.com
  nodename: node2
  description: Database Server
  tags: database,production
  osFamily: unix
  username: dbadmin
  ssh-key-storage-path: keys/project/db-key
```

### Alternative: Resource Model Source (Plugin)
```yaml
# project.properties
resources.source.1.type=url
resources.source.1.config.url=http://inventory.example.com/nodes.json
resources.source.1.config.format=json
resources.source.1.config.timeout=30
```

## Job Definition

### Basic Job (YAML)
```yaml
- defaultTab: nodes
  description: Deploy application to web servers
  executionEnabled: true
  id: 12345678-1234-1234-1234-123456789012
  loglevel: INFO
  name: Deploy Application
  nodeFilterEditable: false
  plugins:
    ExecutionLifecycle: {}
  scheduleEnabled: true
  sequence:
    commands:
    - exec: echo "Starting deployment"
    - script: |-
        #!/bin/bash
        cd /opt/app
        git pull origin main
        docker-compose down
        docker-compose up -d
    keepgoing: false
    strategy: node-first
  uuid: 12345678-1234-1234-1234-123456789012
```

### Job with Options
```yaml
- name: Restart Service
  description: Restart a service on target nodes
  options:
  - name: service_name
    description: Name of the service to restart
    required: true
    value: nginx
    values:
    - nginx
    - apache2
    - postgresql
  - name: wait_time
    description: Wait time after restart (seconds)
    required: false
    value: '10'
    regex: '^\d+$'
  - name: force_restart
    description: Force restart even if service is running
    required: false
    value: 'false'
    values:
    - 'true'
    - 'false'
  sequence:
    commands:
    - exec: sudo systemctl restart ${option.service_name}
    - exec: sleep ${option.wait_time}
    - exec: sudo systemctl status ${option.service_name}
```

### Job with Node Filter
```yaml
- name: Update All Web Servers
  nodefilters:
    dispatch:
      threadcount: 5
      keepgoing: true
      rankOrder: ascending
    filter: 'tags: web+production'
  sequence:
    commands:
    - exec: sudo apt-get update
    - exec: sudo apt-get upgrade -y
    - exec: sudo systemctl restart nginx
```

### Multi-Step Job
```yaml
- name: Complete Deployment Pipeline
  sequence:
    commands:
    # Step 1: Build
    - description: Build Application
      exec: ./build.sh
    
    # Step 2: Run Tests
    - description: Run Unit Tests
      script: |-
        #!/bin/bash
        cd /app
        npm test
      errorhandler:
        exec: echo "Tests failed, sending notification"
    
    # Step 3: Deploy to Staging
    - description: Deploy to Staging
      jobref:
        name: Deploy Application
        project: MyProject
        args: -env staging
    
    # Step 4: Manual Approval
    - description: Wait for Approval
      type: wait
    
    # Step 5: Deploy to Production
    - description: Deploy to Production
      jobref:
        name: Deploy Application
        project: MyProject
        args: -env production
    
    # Step 6: Health Check
    - description: Health Check
      script: |-
        #!/bin/bash
        response=$(curl -s -o /dev/null -w "%{http_code}" http://app.example.com/health)
        if [ $response -eq 200 ]; then
          echo "Health check passed"
          exit 0
        else
          echo "Health check failed"
          exit 1
        fi
```

## Job Scheduling

### Schedule Configuration
```yaml
- name: Daily Backup
  schedule:
    crontab: '0 2 * * *'  # Daily at 2 AM
  sequence:
    commands:
    - exec: /usr/local/bin/backup.sh
```

### Common Cron Expressions
```yaml
# Every 5 minutes
crontab: '*/5 * * * *'

# Every hour
crontab: '0 * * * *'

# Daily at 3 AM
crontab: '0 3 * * *'

# Weekly on Monday at 1 AM
crontab: '0 1 * * 1'

# Monthly on the 1st at midnight
crontab: '0 0 1 * *'

# Weekdays at 9 AM
crontab: '0 9 * * 1-5'
```

## Notifications

### Email Notification
```yaml
- name: Critical Job
  notification:
    onfailure:
      email:
        recipients: ops@example.com,team@example.com
        subject: 'Job Failed: ${job.name}'
        attachLog: true
    onsuccess:
      email:
        recipients: ops@example.com
        subject: 'Job Completed: ${job.name}'
```

### Webhook Notification
```yaml
notification:
  onfailure:
    webhook:
      urls: 'https://hooks.slack.com/services/YOUR/WEBHOOK/URL'
      format: json
      method: POST
```

## Context Variables

### Job Context Variables
```bash
${job.name}                 # Job name
${job.group}                # Job group
${job.id}                   # Job ID
${job.execid}               # Execution ID
${job.username}             # User who ran job
${job.project}              # Project name
${job.loglevel}             # Log level
${job.wasRetry}             # Was this a retry
```

### Option Variables
```bash
${option.service_name}      # Option value
${option.environment}       # Option value
```

### Node Variables
```bash
${node.name}                # Node name
${node.hostname}            # Node hostname
${node.username}            # Node username
${node.tags}                # Node tags
${node.os-family}           # OS family
```

### Data Variables
```bash
${data.value}               # Key storage value
${data.path}                # Key storage path
```

## Node Execution

### Node Filter Syntax
```bash
# Tag filters
tags: web                   # Has tag "web"
tags: web+production        # Has both tags
tags: web,database          # Has either tag

# Attribute filters
name: web.*                 # Regex match
hostname: *.example.com
os-family: unix

# Combined filters
tags: web+production hostname: web0[1-5].*
```

### Execution Strategies
- **node-first**: Execute all steps on node1, then node2, etc.
- **step-first**: Execute step1 on all nodes, then step2, etc.
- **parallel**: Execute steps in parallel across nodes

## API Usage

### Authentication
```bash
# Get API token from UI: User Menu -> Profile -> API Tokens

# Use token in requests
curl -H "X-Rundeck-Auth-Token: YOUR_API_TOKEN" \
  http://rundeck-server:4440/api/VERSION/system/info
```

### Common API Calls
```bash
# List projects
curl -H "X-Rundeck-Auth-Token: $TOKEN" \
  http://localhost:4440/api/40/projects

# List jobs in project
curl -H "X-Rundeck-Auth-Token: $TOKEN" \
  http://localhost:4440/api/40/project/MyProject/jobs

# Run a job
curl -X POST -H "X-Rundeck-Auth-Token: $TOKEN" \
  http://localhost:4440/api/40/job/JOB_ID/run

# Run job with options
curl -X POST -H "X-Rundeck-Auth-Token: $TOKEN" \
  -d "argString=-service_name nginx -environment prod" \
  http://localhost:4440/api/40/job/JOB_ID/run

# Get execution status
curl -H "X-Rundeck-Auth-Token: $TOKEN" \
  http://localhost:4440/api/40/execution/EXEC_ID

# Get execution output
curl -H "X-Rundeck-Auth-Token: $TOKEN" \
  http://localhost:4440/api/40/execution/EXEC_ID/output

# Import job definition
curl -X POST -H "X-Rundeck-Auth-Token: $TOKEN" \
  -H "Content-Type: application/yaml" \
  --data-binary @job.yaml \
  http://localhost:4440/api/40/project/MyProject/jobs/import

# Export jobs
curl -H "X-Rundeck-Auth-Token: $TOKEN" \
  http://localhost:4440/api/40/project/MyProject/jobs/export
```

## Access Control (ACL)

### ACL Policy File (YAML)
```yaml
description: Developers Policy
context:
  project: '.*'  # All projects
for:
  resource:
    - equals:
        kind: job
      allow: [read, run]
    - equals:
        kind: node
      allow: [read]
  adhoc:
    - allow: [read, run]
  job:
    - match:
        name: 'Deploy.*'
      allow: [run]
    - allow: [read]
  node:
    - allow: [read]
by:
  group: developers

---
description: Admin Policy
context:
  application: 'rundeck'
for:
  resource:
    - allow: '*'
  project:
    - allow: '*'
  storage:
    - allow: '*'
by:
  group: admin
```

### ACL Actions
- **read**: View resources
- **create**: Create resources
- **update**: Modify resources
- **delete**: Delete resources
- **run**: Execute jobs
- **kill**: Stop executions
- **admin**: Administrative access

## Key Storage

### Store SSH Key via CLI
```bash
# Store private key
rd keys create -t private -f /path/to/key \
  -p keys/project/mykey

# Store password
rd keys create -t password \
  -p keys/project/db-password \
  -- 'mypassword'
```

### Use in Job
```yaml
- exec: 'mysql -h ${node.hostname} -u admin -p${data.password@keys/project/db-password}'
```

## Plugins

### Common Plugin Types
- **Node Executor**: Execute commands on nodes (SSH, WinRM, Docker)
- **File Copier**: Copy files to nodes
- **Resource Model Source**: Node inventory providers
- **Notification**: Send alerts (Email, Slack, PagerDuty)
- **Workflow Step**: Custom job steps
- **Log Filter**: Process and enhance log output

### Install Plugin
```bash
# Copy plugin to libext directory
cp plugin.jar /var/lib/rundeck/libext/

# Restart Rundeck
systemctl restart rundeckd
```

## Logging

### Log Filters
```yaml
- name: Job with Log Filtering
  sequence:
    commands:
    - exec: 'echo "PASSWORD=secret123"'
    - plugins:
        LogFilter:
        - type: mask-passwords
          config:
            regex: 'PASSWORD=\S+'
            replacement: 'PASSWORD=***MASKED***'
```

### Log Levels
- **DEBUG**: Detailed debugging
- **VERBOSE**: Detailed progress
- **INFO**: General information
- **WARN**: Warnings
- **ERROR**: Errors only

## Common Interview Questions

**Q: What is Rundeck?**
- Open source job scheduler and runbook automation
- Web-based interface for managing jobs
- Executes commands on remote nodes
- Access control and audit logging

**Q: Explain Rundeck architecture**
- Server-based with web UI and API
- Stores job definitions and execution history
- Connects to nodes via SSH/WinRM
- Plugin-based for extensibility

**Q: What are Projects in Rundeck?**
- Isolated workspaces
- Contains jobs, nodes, and executions
- Separate ACLs and configuration
- Organize by team, application, or environment

**Q: How does node filtering work?**
- Filter by tags, attributes, name patterns
- Supports AND (+) and OR (,) operators
- Regex matching for flexibility
- Defined in job or at execution time

**Q: Difference between node-first and step-first?**
- Node-first: All steps on node1, then node2
- Step-first: Step1 on all nodes, then step2
- Choice depends on deployment strategy

**Q: How to pass parameters to jobs?**
- Define options in job definition
- Can be required or optional
- Support validation (regex)
- Predefined value lists
- Secure options for passwords

**Q: What is Key Storage?**
- Secure credential storage
- Store passwords, SSH keys, API tokens
- Access via ${data.password@path}
- Encrypted at rest
- ACL-controlled access

**Q: How to integrate Rundeck with CI/CD?**
- Use Rundeck API
- Trigger jobs via webhook
- Job chaining (jobref step)
- Call from Jenkins, GitLab CI, etc.

**Q: What are execution strategies?**
- node-first, step-first, parallel
- Controls order of execution
- Affects failure handling
- Choose based on requirements

**Q: How to handle secrets?**
- Use Key Storage
- Mark options as secure
- Log filters to mask sensitive data
- Never hardcode in job definitions

**Q: Explain ACL policies**
- YAML-based permissions
- Context: project or application
- Actions: read, run, create, delete
- Subjects: users or groups
- Multiple policies combine

**Q: How to schedule jobs?**
- Cron expression syntax
- UI-based scheduler
- Can enable/disable schedules
- View upcoming executions
