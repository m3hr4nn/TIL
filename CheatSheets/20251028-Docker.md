# Docker Interview Cheat Sheet

## Core Concepts

**Image**: Read-only template with instructions for creating a container
**Container**: Runnable instance of an image
**Dockerfile**: Text file with instructions to build an image
**Registry**: Repository for storing and distributing images (Docker Hub, ECR, GCR)
**Volume**: Persistent data storage outside container lifecycle
**Network**: Communication channel between containers

## Docker Commands

### Image Management
```bash
# List images
docker images
docker image ls

# Pull image from registry
docker pull nginx:latest
docker pull ubuntu:20.04

# Build image from Dockerfile
docker build -t myapp:1.0 .
docker build -t myapp:latest -f Dockerfile.prod .

# Tag image
docker tag myapp:1.0 myapp:latest
docker tag myapp:1.0 registry.example.com/myapp:1.0

# Push image to registry
docker push myapp:1.0

# Remove image
docker rmi nginx:latest
docker rmi -f image_id

# Remove unused images
docker image prune
docker image prune -a

# Inspect image
docker inspect nginx:latest
docker history nginx:latest
```

### Container Lifecycle
```bash
# Run container
docker run nginx
docker run -d nginx                    # Detached mode
docker run -d --name web nginx         # With name
docker run -d -p 8080:80 nginx         # Port mapping
docker run -d -v /host:/container nginx  # Volume mount
docker run -d -e ENV_VAR=value nginx   # Environment variable
docker run -it ubuntu bash             # Interactive with terminal

# List containers
docker ps                              # Running containers
docker ps -a                           # All containers
docker ps -q                           # Only IDs

# Start/Stop/Restart
docker start container_name
docker stop container_name
docker restart container_name

# Pause/Unpause
docker pause container_name
docker unpause container_name

# Remove container
docker rm container_name
docker rm -f container_name            # Force remove running
docker rm $(docker ps -aq)             # Remove all stopped

# Execute command in running container
docker exec -it container_name bash
docker exec container_name ls /app

# View logs
docker logs container_name
docker logs -f container_name          # Follow logs
docker logs --tail 100 container_name  # Last 100 lines

# Inspect container
docker inspect container_name
docker stats container_name            # Resource usage
docker top container_name              # Running processes

# Copy files
docker cp file.txt container_name:/path
docker cp container_name:/path/file.txt .
```

## Dockerfile

### Basic Structure
```dockerfile
# Base image
FROM ubuntu:20.04

# Metadata
LABEL maintainer="user@example.com"
LABEL version="1.0"

# Set working directory
WORKDIR /app

# Copy files
COPY . /app
COPY package.json .

# Add files (supports URLs and tar extraction)
ADD app.tar.gz /app

# Run commands during build
RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip \
    && rm -rf /var/lib/apt/lists/*

# Install dependencies
RUN pip3 install -r requirements.txt

# Set environment variables
ENV APP_ENV=production
ENV PORT=8000

# Expose port
EXPOSE 8000

# Set user (security best practice)
USER appuser

# Volume mount point
VOLUME ["/data"]

# Default command
CMD ["python3", "app.py"]

# Entrypoint (cannot be overridden easily)
ENTRYPOINT ["python3"]
CMD ["app.py"]
```

### Multi-stage Builds
```dockerfile
# Build stage
FROM node:16 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### Best Practices
```dockerfile
# Use specific versions
FROM node:16.14-alpine

# Combine RUN commands to reduce layers
RUN apt-get update && apt-get install -y \
    package1 \
    package2 \
    && rm -rf /var/lib/apt/lists/*

# Use .dockerignore file
# .dockerignore contents:
# node_modules
# .git
# *.md

# Copy package files first (caching)
COPY package*.json ./
RUN npm install
COPY . .

# Run as non-root user
RUN useradd -m appuser
USER appuser
```

## Docker Compose

### docker-compose.yml Example
```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8080:80"
    environment:
      - DATABASE_URL=postgres://db:5432/mydb
    depends_on:
      - db
    volumes:
      - ./app:/app
    networks:
      - app-network
    restart: unless-stopped

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - app-network

  redis:
    image: redis:alpine
    networks:
      - app-network

volumes:
  db-data:

networks:
  app-network:
    driver: bridge
```

### Docker Compose Commands
```bash
# Start services
docker-compose up
docker-compose up -d                   # Detached mode
docker-compose up --build              # Rebuild images

# Stop services
docker-compose down
docker-compose down -v                 # Remove volumes

# View logs
docker-compose logs
docker-compose logs -f web             # Follow specific service

# Execute command
docker-compose exec web bash

# List services
docker-compose ps

# Restart services
docker-compose restart

# Build/rebuild services
docker-compose build
docker-compose build --no-cache

# Scale services
docker-compose up -d --scale web=3
```

## Networking

### Network Commands
```bash
# List networks
docker network ls

# Create network
docker network create my-network
docker network create --driver bridge my-network

# Inspect network
docker network inspect my-network

# Connect container to network
docker network connect my-network container_name

# Disconnect from network
docker network disconnect my-network container_name

# Remove network
docker network rm my-network

# Remove unused networks
docker network prune
```

### Network Types
- **Bridge**: Default network, isolated from host
- **Host**: Container uses host's network stack
- **None**: No networking
- **Overlay**: Multi-host networking (Swarm)
- **Macvlan**: Assign MAC address to container

### Network Usage
```bash
# Run container on specific network
docker run -d --network my-network --name web nginx

# Run container with host network
docker run -d --network host nginx

# Communication between containers
docker run -d --name db postgres
docker run -d --name web --link db:database nginx
```

## Volumes

### Volume Commands
```bash
# List volumes
docker volume ls

# Create volume
docker volume create my-volume

# Inspect volume
docker volume inspect my-volume

# Remove volume
docker volume rm my-volume

# Remove unused volumes
docker volume prune
```

### Volume Types
```bash
# Named volume
docker run -d -v my-volume:/data nginx

# Bind mount (host directory)
docker run -d -v /host/path:/container/path nginx
docker run -d -v $(pwd):/app nginx

# Anonymous volume
docker run -d -v /data nginx

# Read-only mount
docker run -d -v my-volume:/data:ro nginx
```

## Security Best Practices

### Image Security
```dockerfile
# Use official base images
FROM python:3.9-slim

# Run as non-root user
RUN useradd -m -u 1000 appuser
USER appuser

# Don't store secrets in images
# Use environment variables or secrets management

# Scan images for vulnerabilities
docker scan myapp:latest
```

### Container Security
```bash
# Limit resources
docker run -d --memory="512m" --cpus="1" nginx

# Read-only root filesystem
docker run -d --read-only nginx

# Drop capabilities
docker run -d --cap-drop ALL nginx

# Set security options
docker run -d --security-opt no-new-privileges nginx

# Use secrets (Docker Swarm)
echo "mysecret" | docker secret create db_password -
```

## Common Interview Questions

**Q: Difference between CMD and ENTRYPOINT?**
- `CMD`: Default command, can be overridden
- `ENTRYPOINT`: Container executable, harder to override
- Best practice: Use both - ENTRYPOINT for executable, CMD for default args

**Q: What is the difference between COPY and ADD?**
- `COPY`: Simple copy from host to container
- `ADD`: Additional features (URL download, tar extraction)
- Best practice: Use COPY unless you need ADD's features

**Q: Explain Docker layers**
- Each Dockerfile instruction creates a layer
- Layers are cached and reused
- Order matters for caching efficiency
- Fewer layers = smaller image

**Q: How do containers communicate?**
- Within same network: Use container name as hostname
- Port mapping: `-p host:container`
- Legacy: `--link` (deprecated)
- Best: Use custom networks

**Q: Difference between docker run and docker start?**
- `run`: Creates new container from image
- `start`: Starts existing stopped container

**Q: How to reduce Docker image size?**
- Use alpine-based images
- Multi-stage builds
- Combine RUN commands
- Remove unnecessary files
- Use .dockerignore

**Q: What is Docker Swarm?**
- Native clustering and orchestration for Docker
- Manages multiple Docker hosts
- Alternative to Kubernetes

**Q: Explain Docker volumes vs bind mounts**
- Volumes: Managed by Docker, stored in Docker area
- Bind mounts: Direct host filesystem path
- Volumes are preferred for portability

**Q: How to debug a failing container?**
```bash
docker logs container_name
docker inspect container_name
docker exec -it container_name sh
docker run -it image_name sh  # Override entrypoint
```

**Q: What is container orchestration?**
- Managing lifecycle of containers in large, dynamic environments
- Tools: Kubernetes, Docker Swarm, ECS
- Features: Scaling, healing, networking, service discovery
