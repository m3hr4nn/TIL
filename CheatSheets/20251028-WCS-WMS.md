# Warehouse Control System (WCS) & Warehouse Management System (WMS) Cheat Sheet

## Core Concepts

**WMS (Warehouse Management System)**: Software for managing warehouse operations at business level
**WCS (Warehouse Control System)**: Real-time system controlling automated equipment and material handling
**MHE (Material Handling Equipment)**: Physical automation (conveyors, sorters, AS/RS)
**SKU (Stock Keeping Unit)**: Unique identifier for inventory items
**AS/RS (Automated Storage and Retrieval System)**: Automated system for storing/retrieving items
**Pick-to-Light**: Visual system guiding order picking
**Put-to-Light**: Visual system for sorting items

## System Architecture

```
┌─────────────────────────────────┐
│    ERP / Order Management       │
│    (SAP, Oracle, Custom)        │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│    WMS (Business Logic)         │
│  - Inventory Management         │
│  - Order Processing             │
│  - Labor Management             │
│  - Reporting & Analytics        │
└────────────┬────────────────────┘
             │  API/Integration Layer
             ▼
┌─────────────────────────────────┐
│    WCS (Equipment Control)      │
│  - Real-time control            │
│  - Conveyor routing             │
│  - Sorter management            │
│  - PLC communication            │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│    Physical Equipment (MHE)     │
│  - Conveyors                    │
│  - Sorters                      │
│  - AS/RS                        │
│  - Robots (AGV/AMR)             │
└─────────────────────────────────┘
```

## WMS (Warehouse Management System)

### Key Functions

#### 1. Receiving
```python
# Example: Receive inbound shipment
class ReceivingModule:
    def receive_shipment(self, asn_data):
        """
        ASN: Advanced Shipping Notice
        """
        shipment = Shipment.create({
            'asn_number': asn_data['asn_number'],
            'vendor': asn_data['vendor'],
            'expected_date': asn_data['expected_date'],
            'items': asn_data['items']
        })
        
        # Create receiving tasks
        for item in shipment.items:
            ReceivingTask.create({
                'shipment_id': shipment.id,
                'sku': item['sku'],
                'expected_qty': item['quantity'],
                'location': self.assign_receiving_dock()
            })
        
        return shipment

    def confirm_receipt(self, task_id, actual_qty, quality_check):
        task = ReceivingTask.get(task_id)
        task.update({
            'actual_qty': actual_qty,
            'quality_passed': quality_check,
            'received_at': datetime.now()
        })
        
        # Update inventory
        self.update_inventory(task.sku, actual_qty)
        
        # Trigger putaway
        self.create_putaway_task(task)
```

#### 2. Putaway (Storage)
```python
class PutawayModule:
    def create_putaway_task(self, received_item):
        # Find optimal location
        location = self.find_optimal_location(
            sku=received_item.sku,
            quantity=received_item.quantity,
            storage_requirements=received_item.storage_type
        )
        
        task = PutawayTask.create({
            'sku': received_item.sku,
            'quantity': received_item.quantity,
            'from_location': received_item.staging_location,
            'to_location': location,
            'priority': self.calculate_priority(received_item)
        })
        
        return task
    
    def find_optimal_location(self, sku, quantity, storage_requirements):
        """
        Slotting logic based on:
        - Product velocity (fast/slow movers)
        - Size and weight
        - Storage requirements (temp, hazmat)
        - Available capacity
        """
        if self.is_fast_mover(sku):
            # Place near shipping area
            return self.find_near_shipping(capacity=quantity)
        else:
            # Place in bulk storage
            return self.find_bulk_location(capacity=quantity)
```

#### 3. Order Processing & Pick Generation
```python
class OrderModule:
    def process_order(self, order_data):
        order = Order.create({
            'order_number': order_data['order_number'],
            'customer': order_data['customer'],
            'items': order_data['items'],
            'priority': order_data['priority'],
            'ship_by_date': order_data['ship_by_date']
        })
        
        # Check inventory availability
        for item in order.items:
            if not self.check_availability(item['sku'], item['quantity']):
                self.create_backorder(order, item)
        
        # Generate pick tasks
        pick_wave = self.create_pick_wave(order)
        
        return order
    
    def create_pick_wave(self, orders):
        """
        Wave picking: Group orders for efficient picking
        """
        wave = PickWave.create({
            'orders': orders,
            'created_at': datetime.now()
        })
        
        # Batch picking tasks
        tasks = self.batch_pick_tasks(wave.orders)
        
        for task in tasks:
            PickTask.create({
                'wave_id': wave.id,
                'sku': task['sku'],
                'quantity': task['quantity'],
                'from_location': task['location'],
                'assigned_to': self.assign_picker(),
                'sequence': task['sequence']  # Optimized route
            })
        
        return wave
```

#### 4. Inventory Management
```python
class InventoryModule:
    def update_inventory(self, sku, quantity, location, transaction_type):
        inventory = Inventory.get_or_create(sku=sku, location=location)
        
        Transaction.create({
            'sku': sku,
            'location': location,
            'quantity': quantity,
            'type': transaction_type,  # RECEIPT, PICK, ADJUSTMENT, CYCLE_COUNT
            'timestamp': datetime.now()
        })
        
        if transaction_type in ['RECEIPT', 'PUTAWAY']:
            inventory.quantity += quantity
        elif transaction_type in ['PICK', 'SHIPMENT']:
            inventory.quantity -= quantity
        
        inventory.last_updated = datetime.now()
        inventory.save()
        
        # Update stock levels
        self.check_reorder_point(sku)
    
    def cycle_count(self, location):
        """
        Physical inventory count
        """
        expected = Inventory.filter(location=location)
        actual_counts = self.scanner_input()  # From handheld device
        
        discrepancies = []
        for item in expected:
            actual = actual_counts.get(item.sku, 0)
            if actual != item.quantity:
                discrepancies.append({
                    'sku': item.sku,
                    'expected': item.quantity,
                    'actual': actual,
                    'variance': actual - item.quantity
                })
                
                # Create adjustment
                self.create_adjustment(item.sku, actual - item.quantity, location)
        
        return discrepancies
```

#### 5. Shipping
```python
class ShippingModule:
    def create_shipment(self, order_id):
        order = Order.get(order_id)
        picked_items = PickTask.filter(order_id=order_id, status='COMPLETED')
        
        shipment = Shipment.create({
            'order_id': order_id,
            'items': picked_items,
            'carrier': self.select_carrier(order),
            'service_level': order.shipping_method
        })
        
        # Generate shipping label
        label = self.generate_shipping_label(shipment)
        
        # Update order status
        order.status = 'SHIPPED'
        order.shipped_at = datetime.now()
        order.tracking_number = label.tracking_number
        order.save()
        
        # Send notification
        self.notify_customer(order, label.tracking_number)
        
        return shipment
```

## WCS (Warehouse Control System)

### Key Functions

#### 1. Conveyor Control
```python
class ConveyorController:
    def route_package(self, package_id, barcode_data):
        """
        Real-time routing decision
        """
        package = self.identify_package(barcode_data)
        destination = self.determine_destination(package)
        
        # Send command to PLC
        command = {
            'package_id': package_id,
            'current_zone': package.current_zone,
            'target_zone': destination.zone,
            'divert_action': 'RIGHT' if destination.side == 'right' else 'LEFT',
            'speed': self.calculate_speed(package.weight)
        }
        
        self.send_to_plc(command)
        
        # Log tracking
        self.log_package_movement(package_id, command)
    
    def handle_jam(self, zone_id):
        """
        Handle conveyor jam
        """
        # Stop affected zones
        affected_zones = self.get_upstream_zones(zone_id)
        for zone in affected_zones:
            self.stop_zone(zone)
        
        # Alert maintenance
        self.create_maintenance_alert(zone_id, 'JAM')
        
        # Reroute packages
        self.reroute_packages(zone_id)
```

#### 2. Sorter Management
```python
class SorterController:
    def initialize_sort_plan(self, wave_id):
        """
        Configure sorter for wave
        """
        wave = PickWave.get(wave_id)
        
        # Assign destinations to sorter chutes
        chute_assignments = {}
        for order in wave.orders:
            chute = self.assign_chute(order)
            chute_assignments[order.id] = chute
        
        # Program sorter
        self.program_sorter(chute_assignments)
        
        return chute_assignments
    
    def sort_item(self, scan_data):
        """
        Real-time sorting decision
        """
        item = self.parse_barcode(scan_data)
        order = self.find_order(item.order_id)
        chute = self.chute_assignments[order.id]
        
        # Trigger divert mechanism
        self.trigger_divert(chute, item.position_on_belt)
        
        # Update WMS
        self.update_sort_status(item.id, chute)
```

#### 3. AS/RS Control
```python
class ASRSController:
    def store_pallet(self, pallet_id, sku, quantity):
        """
        Automated storage
        """
        # Find available location
        location = self.find_optimal_storage_location(
            size=self.get_pallet_size(pallet_id),
            weight=self.get_pallet_weight(pallet_id),
            temperature_zone=sku.storage_requirements.temperature
        )
        
        # Send crane command
        crane_command = {
            'action': 'STORE',
            'pallet_id': pallet_id,
            'from': self.inbound_station,
            'to': location,
            'priority': self.calculate_priority(sku)
        }
        
        self.send_crane_command(crane_command)
        
        # Update WMS
        self.update_inventory_location(pallet_id, location)
    
    def retrieve_pallet(self, location):
        """
        Automated retrieval
        """
        crane_command = {
            'action': 'RETRIEVE',
            'from': location,
            'to': self.outbound_station
        }
        
        self.send_crane_command(crane_command)
        
        # Wait for completion
        self.wait_for_crane(timeout=60)
```

#### 4. AGV/AMR Control
```python
class RobotController:
    def dispatch_robot(self, task):
        """
        Dispatch autonomous robot
        """
        # Find available robot
        robot = self.find_nearest_available_robot(task.pickup_location)
        
        # Calculate route
        route = self.calculate_optimal_route(
            start=robot.current_location,
            pickup=task.pickup_location,
            dropoff=task.dropoff_location,
            obstacles=self.get_current_obstacles()
        )
        
        # Send mission
        mission = {
            'robot_id': robot.id,
            'task_id': task.id,
            'route': route,
            'actions': [
                {'type': 'NAVIGATE', 'to': task.pickup_location},
                {'type': 'LOAD', 'item': task.item_id},
                {'type': 'NAVIGATE', 'to': task.dropoff_location},
                {'type': 'UNLOAD'}
            ]
        }
        
        self.send_robot_mission(mission)
        
        # Monitor execution
        self.monitor_robot(robot.id, mission)
```

## Integration Layer

### WMS-WCS Integration
```python
class WarehouseMiddleware:
    def __init__(self):
        self.wms_api = WMS_API()
        self.wcs_api = WCS_API()
        self.message_queue = MessageQueue()
    
    def handle_pick_task_completion(self, pick_task_id):
        """
        WMS → WCS: Item picked, route to sorter
        """
        pick_task = self.wms_api.get_pick_task(pick_task_id)
        
        # Send to WCS for routing
        routing_request = {
            'item_id': pick_task.item_id,
            'order_id': pick_task.order_id,
            'destination': pick_task.pack_station,
            'priority': pick_task.priority
        }
        
        self.wcs_api.route_item(routing_request)
    
    def handle_sort_completion(self, item_id, chute_id):
        """
        WCS → WMS: Item sorted to destination
        """
        # Update WMS
        self.wms_api.update_item_location(item_id, chute_id)
        
        # Check if order complete
        order = self.wms_api.get_order_for_item(item_id)
        if self.wms_api.is_order_complete(order.id):
            # Trigger packing
            self.wms_api.create_pack_task(order.id)
    
    def handle_inventory_move(self, from_location, to_location, sku, quantity):
        """
        WMS → WCS: Move inventory
        """
        # Request WCS to move
        move_request = {
            'from': from_location,
            'to': to_location,
            'sku': sku,
            'quantity': quantity
        }
        
        self.wcs_api.create_move_task(move_request)
        
        # Update WMS when complete
        def on_complete(task_id):
            self.wms_api.update_inventory_location(sku, to_location, quantity)
        
        self.wcs_api.on_task_complete(move_request['task_id'], on_complete)
```

## Common Interfaces

### REST API Example
```python
# WMS API Endpoint
@app.route('/api/wms/orders', methods=['POST'])
def create_order():
    order_data = request.json
    order = wms.process_order(order_data)
    
    # Trigger WCS routing if automation available
    if wcs.is_available():
        wcs.prepare_for_order(order.id)
    
    return jsonify(order.to_dict()), 201

# WCS API Endpoint
@app.route('/api/wcs/route', methods=['POST'])
def route_item():
    routing_data = request.json
    result = wcs.route_package(
        package_id=routing_data['package_id'],
        destination=routing_data['destination']
    )
    return jsonify(result), 200
```

### Message Queue Integration
```python
# Using RabbitMQ for async communication
import pika

class MessageBroker:
    def __init__(self):
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters('localhost')
        )
        self.channel = self.connection.channel()
        
        # Declare exchanges and queues
        self.channel.exchange_declare(exchange='warehouse', exchange_type='topic')
        self.channel.queue_declare(queue='wms_to_wcs')
        self.channel.queue_declare(queue='wcs_to_wms')
    
    def publish_pick_complete(self, pick_task):
        message = {
            'event': 'pick.completed',
            'task_id': pick_task.id,
            'item_id': pick_task.item_id,
            'destination': pick_task.destination,
            'timestamp': datetime.now().isoformat()
        }
        
        self.channel.basic_publish(
            exchange='warehouse',
            routing_key='wms.pick.completed',
            body=json.dumps(message)
        )
    
    def subscribe_sort_events(self, callback):
        def on_message(ch, method, properties, body):
            event = json.loads(body)
            callback(event)
        
        self.channel.basic_consume(
            queue='wcs_to_wms',
            on_message_callback=on_message,
            auto_ack=True
        )
        
        self.channel.start_consuming()
```

## Common Interview Questions

**Q: What is the difference between WMS and WCS?**
- WMS: Business logic, inventory management, order processing
- WCS: Real-time equipment control, automation interface
- WMS decides WHAT to do, WCS decides HOW to do it
- WMS manages data, WCS controls physical movement

**Q: How do WMS and WCS communicate?**
- REST APIs for request-response
- Message queues (RabbitMQ, Kafka) for async events
- Database integration (shared or replicated)
- Direct socket connections for real-time data

**Q: What is wave picking?**
- Grouping multiple orders for efficient picking
- Batch picking multiple SKUs in one trip
- Reduces travel time
- Optimizes labor utilization

**Q: Explain slotting optimization**
- Placing fast-movers near shipping
- High-volume items in accessible locations
- Grouping similar items
- Considers size, weight, storage requirements

**Q: What is cycle counting?**
- Continuous inventory counting
- Alternative to annual physical inventory
- ABC analysis (focus on high-value items)
- Identifies and corrects discrepancies

**Q: How to handle equipment failures?**
- Redundancy and failover systems
- Graceful degradation (manual processes)
- Real-time monitoring and alerts
- Maintenance schedules and predictive maintenance

**Q: What is pick-to-light/put-to-light?**
- Visual picking system with lights
- Reduces errors and increases speed
- Common in order fulfillment centers
- Integrated with WCS for real-time control

**Q: Explain FIFO, LIFO, FEFO**
- FIFO: First In, First Out (standard)
- LIFO: Last In, First Out (rare in warehousing)
- FEFO: First Expired, First Out (for perishables)

**Q: How to ensure order accuracy?**
- Barcode scanning at each step
- Weight verification
- Vision systems for validation
- Quality checkpoints

**Q: What is cartonization?**
- Determining optimal box size for order
- Minimizes packaging material
- Reduces shipping costs
- Automated by WMS based on item dimensions
