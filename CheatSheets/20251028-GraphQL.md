# GraphQL Interview Cheat Sheet

## Core Concepts

**GraphQL**: Query language for APIs and runtime for executing queries
**Schema**: Defines types and relationships (contract between client and server)
**Query**: Read operation to fetch data
**Mutation**: Write operation to modify data
**Subscription**: Real-time data updates via WebSocket
**Resolver**: Function that returns data for a field
**Type**: Definition of data structure
**Field**: Individual piece of data in a type
**Argument**: Parameter passed to a field or query

## Schema Definition Language (SDL)

### Basic Types
```graphql
# Scalar types
String
Int
Float
Boolean
ID

# Custom scalar
scalar Date
scalar JSON

# Object type
type User {
  id: ID!              # ! means non-nullable
  name: String!
  email: String!
  age: Int
  posts: [Post!]!      # Array of Posts
  createdAt: Date!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  comments: [Comment!]!
  published: Boolean!
}

type Comment {
  id: ID!
  text: String!
  author: User!
  post: Post!
}
```

### Enums
```graphql
enum Role {
  ADMIN
  USER
  GUEST
}

enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

type User {
  id: ID!
  name: String!
  role: Role!
}
```

### Interfaces
```graphql
interface Node {
  id: ID!
}

interface Timestamped {
  createdAt: Date!
  updatedAt: Date!
}

type User implements Node & Timestamped {
  id: ID!
  name: String!
  createdAt: Date!
  updatedAt: Date!
}

type Post implements Node & Timestamped {
  id: ID!
  title: String!
  createdAt: Date!
  updatedAt: Date!
}
```

### Unions
```graphql
union SearchResult = User | Post | Comment

type Query {
  search(query: String!): [SearchResult!]!
}
```

### Input Types
```graphql
input CreateUserInput {
  name: String!
  email: String!
  age: Int
  role: Role
}

input UpdateUserInput {
  name: String
  email: String
  age: Int
}

input PostFilter {
  status: PostStatus
  authorId: ID
  minDate: Date
  maxDate: Date
}
```

## Schema Definition

### Root Types
```graphql
schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Query {
  # Get single resource
  user(id: ID!): User
  post(id: ID!): Post
  
  # Get list of resources
  users(limit: Int, offset: Int): [User!]!
  posts(filter: PostFilter, limit: Int): [Post!]!
  
  # Search
  search(query: String!): [SearchResult!]!
  
  # Aggregations
  userCount: Int!
  postStats: PostStats!
}

type Mutation {
  # Create
  createUser(input: CreateUserInput!): User!
  createPost(title: String!, content: String!): Post!
  
  # Update
  updateUser(id: ID!, input: UpdateUserInput!): User!
  updatePost(id: ID!, title: String, content: String): Post!
  
  # Delete
  deleteUser(id: ID!): Boolean!
  deletePost(id: ID!): Boolean!
  
  # Actions
  publishPost(id: ID!): Post!
  likePost(id: ID!): Post!
}

type Subscription {
  postCreated: Post!
  postUpdated(id: ID!): Post!
  commentAdded(postId: ID!): Comment!
  userOnline: User!
}
```

## Queries

### Basic Query
```graphql
query {
  users {
    id
    name
    email
  }
}

# With specific fields
query {
  user(id: "123") {
    id
    name
    email
  }
}
```

### Nested Queries
```graphql
query {
  user(id: "123") {
    id
    name
    posts {
      id
      title
      comments {
        id
        text
        author {
          name
        }
      }
    }
  }
}
```

### Query with Arguments
```graphql
query {
  posts(limit: 10, filter: { status: PUBLISHED }) {
    id
    title
    author {
      name
    }
  }
}
```

### Named Queries with Variables
```graphql
query GetUser($userId: ID!) {
  user(id: $userId) {
    id
    name
    email
  }
}

# Variables (sent separately)
{
  "userId": "123"
}
```

### Multiple Queries
```graphql
query {
  user1: user(id: "123") {
    name
  }
  user2: user(id: "456") {
    name
  }
}
```

### Fragments
```graphql
fragment UserFields on User {
  id
  name
  email
}

query {
  user1: user(id: "123") {
    ...UserFields
  }
  user2: user(id: "456") {
    ...UserFields
  }
}

# Inline fragments (for unions/interfaces)
query {
  search(query: "test") {
    ... on User {
      name
      email
    }
    ... on Post {
      title
      content
    }
    ... on Comment {
      text
    }
  }
}
```

### Directives
```graphql
query GetUser($userId: ID!, $withPosts: Boolean!) {
  user(id: $userId) {
    id
    name
    posts @include(if: $withPosts) {
      title
    }
  }
}

# @skip directive
query GetUser($userId: ID!, $skipEmail: Boolean!) {
  user(id: $userId) {
    id
    name
    email @skip(if: $skipEmail)
  }
}

# @deprecated directive (in schema)
type User {
  id: ID!
  name: String!
  oldField: String @deprecated(reason: "Use newField instead")
  newField: String
}
```

## Mutations

### Basic Mutation
```graphql
mutation {
  createUser(input: {
    name: "John Doe"
    email: "john@example.com"
    age: 30
  }) {
    id
    name
    email
  }
}
```

### Named Mutation with Variables
```graphql
mutation CreateUser($input: CreateUserInput!) {
  createUser(input: $input) {
    id
    name
    email
  }
}

# Variables
{
  "input": {
    "name": "John Doe",
    "email": "john@example.com",
    "age": 30
  }
}
```

### Update Mutation
```graphql
mutation UpdateUser($id: ID!, $input: UpdateUserInput!) {
  updateUser(id: $id, input: $input) {
    id
    name
    email
    updatedAt
  }
}
```

### Multiple Mutations
```graphql
mutation {
  createPost(title: "Post 1", content: "Content 1") {
    id
  }
  createPost(title: "Post 2", content: "Content 2") {
    id
  }
}
# Note: Mutations execute sequentially
```

## Subscriptions

### Basic Subscription
```graphql
subscription {
  postCreated {
    id
    title
    author {
      name
    }
  }
}
```

### Subscription with Arguments
```graphql
subscription OnCommentAdded($postId: ID!) {
  commentAdded(postId: $postId) {
    id
    text
    author {
      name
    }
  }
}
```

## Server Implementation (Node.js/Apollo)

### Setup
```javascript
const { ApolloServer, gql } = require('apollo-server');

// Type definitions
const typeDefs = gql`
  type User {
    id: ID!
    name: String!
    email: String!
    posts: [Post!]!
  }

  type Post {
    id: ID!
    title: String!
    content: String!
    author: User!
  }

  type Query {
    users: [User!]!
    user(id: ID!): User
    posts: [Post!]!
  }

  type Mutation {
    createUser(name: String!, email: String!): User!
    createPost(title: String!, content: String!, authorId: ID!): Post!
  }
`;

// Resolvers
const resolvers = {
  Query: {
    users: () => users,
    user: (parent, args) => users.find(u => u.id === args.id),
    posts: () => posts,
  },
  
  Mutation: {
    createUser: (parent, args) => {
      const user = {
        id: String(users.length + 1),
        name: args.name,
        email: args.email,
      };
      users.push(user);
      return user;
    },
    
    createPost: (parent, args) => {
      const post = {
        id: String(posts.length + 1),
        title: args.title,
        content: args.content,
        authorId: args.authorId,
      };
      posts.push(post);
      return post;
    },
  },
  
  // Field resolvers
  User: {
    posts: (parent) => posts.filter(p => p.authorId === parent.id),
  },
  
  Post: {
    author: (parent) => users.find(u => u.id === parent.authorId),
  },
};

// Create server
const server = new ApolloServer({
  typeDefs,
  resolvers,
  context: ({ req }) => {
    // Add context (auth, database, etc.)
    const token = req.headers.authorization || '';
    return { token };
  },
});

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`);
});
```

### Context and Authentication
```javascript
const resolvers = {
  Query: {
    me: (parent, args, context) => {
      if (!context.user) {
        throw new Error('Not authenticated');
      }
      return context.user;
    },
  },
  
  Mutation: {
    createPost: (parent, args, context) => {
      if (!context.user) {
        throw new Error('Not authenticated');
      }
      // Create post with context.user.id
    },
  },
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
  context: async ({ req }) => {
    const token = req.headers.authorization || '';
    const user = await getUserFromToken(token);
    return { user };
  },
});
```

### DataLoader (N+1 Problem)
```javascript
const DataLoader = require('dataloader');

const userLoader = new DataLoader(async (userIds) => {
  const users = await db.users.findAll({
    where: { id: userIds }
  });
  // Return in same order as requested
  return userIds.map(id => users.find(u => u.id === id));
});

const resolvers = {
  Post: {
    author: (parent, args, context) => {
      return context.loaders.user.load(parent.authorId);
    },
  },
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
  context: () => ({
    loaders: {
      user: userLoader,
    },
  }),
});
```

## Client Implementation

### Apollo Client (React)
```javascript
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery, useMutation } from '@apollo/client';

// Setup client
const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
  headers: {
    authorization: `Bearer ${token}`,
  },
});

// Wrap app
function App() {
  return (
    <ApolloProvider client={client}>
      <Users />
    </ApolloProvider>
  );
}

// Query component
const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
      email
    }
  }
`;

function Users() {
  const { loading, error, data, refetch } = useQuery(GET_USERS);
  
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;
  
  return (
    <div>
      {data.users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
      <button onClick={() => refetch()}>Refresh</button>
    </div>
  );
}

// Mutation component
const CREATE_USER = gql`
  mutation CreateUser($name: String!, $email: String!) {
    createUser(name: $name, email: $email) {
      id
      name
      email
    }
  }
`;

function CreateUser() {
  const [createUser, { data, loading, error }] = useMutation(CREATE_USER, {
    refetchQueries: [{ query: GET_USERS }],
  });
  
  const handleSubmit = (e) => {
    e.preventDefault();
    createUser({
      variables: {
        name: 'John Doe',
        email: 'john@example.com',
      },
    });
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}

// Subscription
const POST_CREATED = gql`
  subscription OnPostCreated {
    postCreated {
      id
      title
    }
  }
`;

function Posts() {
  const { data, loading } = useSubscription(POST_CREATED);
  // Handle real-time updates
}
```

### Query with Variables
```javascript
const GET_USER = gql`
  query GetUser($id: ID!) {
    user(id: $id) {
      id
      name
      email
    }
  }
`;

function UserProfile({ userId }) {
  const { loading, error, data } = useQuery(GET_USER, {
    variables: { id: userId },
  });
  
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error!</p>;
  
  return <div>{data.user.name}</div>;
}
```

## Best Practices

### Schema Design
```graphql
# Good: Descriptive names
type User {
  id: ID!
  fullName: String!
  emailAddress: String!
}

# Good: Use enums for fixed values
enum UserRole {
  ADMIN
  USER
  GUEST
}

# Good: Pagination
type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  node: User!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  users(first: Int, after: String): UserConnection!
}
```

### Error Handling
```javascript
const resolvers = {
  Query: {
    user: async (parent, { id }) => {
      try {
        const user = await db.users.findById(id);
        if (!user) {
          throw new Error('User not found');
        }
        return user;
      } catch (error) {
        throw new Error(`Failed to fetch user: ${error.message}`);
      }
    },
  },
};

// Custom errors
class NotFoundError extends Error {
  constructor(message) {
    super(message);
    this.extensions = { code: 'NOT_FOUND' };
  }
}
```

## Common Interview Questions

**Q: What is GraphQL?**
- Query language for APIs
- Client specifies exact data needed
- Single endpoint (vs REST multiple endpoints)
- Strongly typed schema
- Reduces over-fetching and under-fetching

**Q: GraphQL vs REST?**
- GraphQL: Single endpoint, flexible queries, typed
- REST: Multiple endpoints, fixed responses, less structured
- GraphQL: Better for complex data needs
- REST: Simpler for basic CRUD, better caching

**Q: What are resolvers?**
- Functions that return data for fields
- Map schema fields to data sources
- Can be async
- Receive parent, args, context, info

**Q: What is the N+1 problem?**
- Multiple database queries for related data
- Example: Fetching users, then posts for each user
- Solution: DataLoader for batching and caching
- Groups requests into single query

**Q: Explain fragments**
- Reusable units of fields
- Reduce query duplication
- Inline fragments for unions/interfaces
- Named fragments for sharing

**Q: What are directives?**
- @include(if: Boolean): Conditionally include field
- @skip(if: Boolean): Conditionally skip field
- @deprecated: Mark field as deprecated
- Custom directives possible

**Q: How to handle authentication?**
- Pass token in HTTP headers
- Validate in context function
- Check permissions in resolvers
- Use middleware/guards

**Q: What is schema stitching?**
- Combine multiple GraphQL schemas
- Create unified API from microservices
- Federation is modern approach
- Apollo Federation recommended

**Q: Explain subscriptions**
- Real-time data updates
- Uses WebSocket protocol
- Server pushes data to clients
- Event-driven architecture

**Q: How to optimize performance?**
- Use DataLoader (batching/caching)
- Query complexity limits
- Depth limiting
- Persisted queries
- APQ (Automatic Persisted Queries)
- Proper indexing on database

**Q: What is introspection?**
- Query schema structure at runtime
- Used by GraphQL tools
- Should disable in production
- Security consideration

**Q: Advantages of GraphQL?**
- Precise data fetching
- Single request for complex data
- Strong typing
- Self-documenting
- Rapid development
- Versionless API
